context.objects = [
    # An example clock reading from /dev/ptp0. You can also specify the network interface name,
    # pipewire will query the interface for the current active PHC index. Another option is to
    # sync the ptp clock to CLOCK_TAI and then set clock.id = tai, keep in mind that tai may
    # also be synced by a NTP client.
    # The precedence is: device, interface, id
    { factory = spa-node-factory
        args = {
            factory.name    = support.node.driver
            node.name       = PTP0-Driver
            node.group      = pipewire.ptp0
            # This driver should only be used for network nodes marked with group
            priority.driver = 100000
            clock.name      = "clock.system.ptp0"
            ### Please select the PTP hardware clock here
            # Interface name is the preferred method of specifying the PHC
            clock.interface = "eth0"
            clock.device    = "/dev/ptp0"
            #clock.id        = tai
            # Lower this in case of periodic out-of-sync
            resync.ms       = 1.5
            object.export   = true
        }
    }
]
context.modules = [
    { name = libpipewire-module-rtp-sink
      args = {
        source.ip = "192.168.88.174" # myself, IP of the OSMC PI
        destination.ip = "192.168.88.175" # Consumer RPI IP
        destination.port = 46000
        #local.ifname = "eth0"
        net.mtu = 1280
        net.ttl = 1
        #sess.min-ptime = 2
        #sess.max-ptime = 20
        sess.name = "Pi RTP Exile"
        sess.latency.msec = 4
        #audio.format = "S16BE" # hmm, keep for now but we may need this to be S24BE
        #audio.rate = 48000
        #audio.channels = 2 # we will up later, after this works (ha, if only)
        #audio.position = [ FL FR ]
        stream.props = {
          node.name = "rtp_sink"
          node.description = "Network Audio Outpost"
          media.class = Audio/Sink
        }
      }
    }
]
