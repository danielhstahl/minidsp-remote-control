# AES67 config file for PipeWire version "1.4.7" #
#
# Copy and edit this file in /etc/pipewire for system-wide changes
# or in ~/.config/pipewire for local changes.
#
# It is also possible to place a file with an updated section in
# /etc/pipewire/pipewire-aes67.conf.d/ for system-wide changes or in
# ~/.config/pipewire/pipewire-aes67.conf.d/ for local changes.
#

context.properties = {
    ## Configure properties in the system.
    #mem.warn-mlock  = false
    #mem.allow-mlock = true
    #mem.mlock-all   = false
    #log.level       = 2

    # temporary, need to hve more logs
    log.level       = 4

    #default.clock.quantum-limit = 8192
}

context.spa-libs = {
    support.*       = support/libspa-support
}

context.objects = [
    # An example clock reading from /dev/ptp0. You can also specify the network interface name,
    # pipewire will query the interface for the current active PHC index. Another option is to
    # sync the ptp clock to CLOCK_TAI and then set clock.id = tai, keep in mind that tai may
    # also be synced by a NTP client.
    # The precedence is: device, interface, id
    { factory = spa-node-factory
        args = {
            factory.name    = support.node.driver
            node.name       = PTP0-Driver
            node.group      = pipewire.ptp0
            # This driver should only be used for network nodes marked with group
            priority.driver = 100000
            clock.name      = "clock.system.ptp0"
            ### Please select the PTP hardware clock here
            # Interface name is the preferred method of specifying the PHC
            clock.interface = "eth0"
            #clock.device    = "/dev/ptp0"
            #clock.id        = tai
            # Lower this in case of periodic out-of-sync
            resync.ms       = 1.5
            object.export   = true
        }
    }
]

context.modules = [
    { name = libpipewire-module-rt
        args = {
            nice.level   = -11
            #rt.prio      = 83
            #rt.time.soft = -1
            #rt.time.hard = -1
        }
        flags = [ ifexists nofail ]
    }
    { name = libpipewire-module-rtp-sap
        flags = [ ifexists nofail ]
        args = {
            ### Please select the interface here
            local.ifname = eth0
            sap.ip = 239.255.255.255
            sap.port = 9875
            net.ttl = 32
            net.loop = false
            # If you use another PTPv2 daemon supporting management
            # messages over a UNIX socket, specify its path here
            ptp.management-socket = "/var/run/ptp4lro"

            stream.rules = [
                {
                    matches = [
                        {
                            sess.sap.announce = true
                            rtp.session = "~.*"
                            # uncomment this to filter only the prodcuer
                            #sess.name = "PipeWire RTP stream OSMC"
                        }
                    ]
                    actions = {
                        announce-stream = {}
                        create-stream = {
                            # These get passed as args to dynamic libpipewire-module-rtp-source load
                            # SDP overrides (port/ip/format/etc.), but set sane defaults
                            # source.port = 5004  # Fallback; SDP sets real one
                            local.ifname = eth0
                            sess.latency.msec = 3
                            sess.ts-direct = true
                            # sess.ts-refclk = "ptp=traceable"
                            audio.format = "S24BE"
                            audio.rate = 48000
                            audio.channels = 8
                            node.always-process = true
                            stream.props = {
                                media.class = "Audio/Source"
                                node.name = "rtp-source-osmc"
                                node.group = pipewire.ptp0
                                node.virtual = false
                                device.api = aes67
                                node.channel-names = ["L", "R", "C", "LFE", "LsS", "RsS", "LsR", "RsR"]
                            }
                        }
                    }
               }
            ]

        }
    }
]
